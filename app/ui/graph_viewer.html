<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GraphRAG Graph Viewer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1e1e1e;
            color: #e0e0e0;
            padding: 20px;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            margin-bottom: 20px;
        }

        h1 {
            color: #4a9eff;
            margin-bottom: 10px;
        }

        .controls {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        label {
            color: #aaa;
            font-size: 14px;
        }

        input, select, button {
            background: #3d3d3d;
            color: #e0e0e0;
            border: 1px solid #555;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
        }

        button {
            background: #4a9eff;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background: #357abd;
        }

        .graph-container {
            flex: 1;
            background: #2d2d2d;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        #graph {
            width: 100%;
            height: 100%;
        }

        .node {
            cursor: pointer;
        }

        .node circle {
            stroke: #fff;
            stroke-width: 2px;
        }

        .link {
            stroke: #666;
            stroke-opacity: 0.6;
            stroke-width: 2px;
        }

        .node-label {
            font-size: 12px;
            fill: #e0e0e0;
            pointer-events: none;
        }

        .link-label {
            font-size: 10px;
            fill: #888;
            pointer-events: none;
        }

        .detail-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            max-width: 300px;
            display: none;
            border: 2px solid #4a9eff;
        }

        .detail-panel.active {
            display: block;
        }

        .detail-panel h3 {
            color: #4a9eff;
            margin-bottom: 10px;
        }

        .detail-panel .close-btn {
            background: #f44336;
            margin-top: 10px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-size: 18px;
        }

        .error {
            background: #4a2d2d;
            border: 2px solid #f44336;
            border-radius: 8px;
            padding: 15px;
            color: #ff6b6b;
            margin-bottom: 20px;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: #2d2d2d;
            border-radius: 8px;
            padding: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>GraphRAG Interactive Graph Viewer</h1>
            <div class="controls">
                <div class="control-group">
                    <label>Database:</label>
                    <input type="text" id="dbName" placeholder="mongo_hack" value="mongo_hack" style="width: 150px;">
                </div>
                <div class="control-group">
                    <label>Entity ID (Ego Network):</label>
                    <input type="text" id="entityId" placeholder="Enter entity ID for ego network" style="width: 300px;">
                </div>
                <div class="control-group">
                    <label>Max Hops:</label>
                    <input type="number" id="maxHops" min="1" max="5" value="2" style="width: 60px;">
                </div>
                <div class="control-group">
                    <label>Community ID:</label>
                    <input type="text" id="communityId" placeholder="Enter community ID" style="width: 300px;">
                </div>
                <div class="control-group">
                    <label>Max Nodes:</label>
                    <input type="number" id="maxNodes" min="10" max="500" value="100" style="width: 80px;">
                </div>
                <div class="control-group">
                    <label>Filter Predicate:</label>
                    <select id="predicateFilter" style="width: 150px;">
                        <option value="">All Predicates</option>
                    </select>
                </div>
                <button onclick="loadGraph()">Load Graph</button>
                <button onclick="resetView()">Reset View</button>
                <button onclick="exportGraph()">Export Graph</button>
            </div>
            <div id="error" class="error" style="display: none;"></div>
        </div>

        <div class="graph-container">
            <div id="loading" class="loading" style="display: none;">Loading graph...</div>
            <svg id="graph"></svg>
            <div id="detailPanel" class="detail-panel"></div>
            <div class="legend">
                <div style="color: #4a9eff; font-weight: bold; margin-bottom: 10px;">Entity Types</div>
                <div class="legend-item"><div class="legend-color" style="background: #4a9eff;"></div><span>Person</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #4caf50;"></div><span>Organization</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #ff9800;"></div><span>Technology</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #9c27b0;"></div><span>Concept</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #f44336;"></div><span>Other</span></div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = window.location.origin || 'http://localhost:8000';
        let graphData = { nodes: [], links: [] };
        let simulation = null;
        let svg = null;

        const typeColors = {
            'PERSON': '#4a9eff',
            'ORGANIZATION': '#4caf50',
            'TECHNOLOGY': '#ff9800',
            'CONCEPT': '#9c27b0',
            'LOCATION': '#00bcd4',
            'EVENT': '#ff5722',
            'OTHER': '#f44336',
        };

        async function loadGraph() {
            const dbName = document.getElementById('dbName').value.trim();
            const entityId = document.getElementById('entityId').value.trim();
            const communityId = document.getElementById('communityId').value.trim();
            const maxNodes = parseInt(document.getElementById('maxNodes').value) || 100;

            if (!dbName) {
                showError('Please enter a database name');
                return;
            }

            document.getElementById('loading').style.display = 'block';
            document.getElementById('error').style.display = 'none';
            closeDetailPanel();

            try {
                // Load predicate filter options
                await loadPredicateFilterOptions(dbName);
                
                if (communityId) {
                    // Load community graph
                    await loadCommunityGraph(dbName, communityId);
                } else if (entityId) {
                    // Load ego network
                    await loadEgoNetwork(dbName, entityId, maxNodes);
                } else {
                    // Load sample graph (top entities by source_count)
                    await loadSampleGraph(dbName, maxNodes);
                }
                
                // Apply predicate filter if selected
                const predicateFilter = document.getElementById('predicateFilter').value;
                if (predicateFilter) {
                    filterByPredicate(predicateFilter);
                }
            } catch (error) {
                showError(`Error loading graph: ${error.message}`);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        async function loadPredicateFilterOptions(dbName) {
            // Get unique predicates from relationships
            try {
                const response = await fetch(`${API_BASE}/api/relationships/search?db_name=${dbName}&limit=1000`);
                if (response.ok) {
                    const data = await response.json();
                    const predicates = new Set();
                    data.relationships.forEach(rel => {
                        if (rel.predicate) predicates.add(rel.predicate);
                    });
                    
                    const select = document.getElementById('predicateFilter');
                    // Clear existing options except "All Predicates"
                    while (select.options.length > 1) {
                        select.remove(1);
                    }
                    
                    // Add predicate options
                    Array.from(predicates).sort().forEach(pred => {
                        const option = document.createElement('option');
                        option.value = pred;
                        option.textContent = pred;
                        select.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Error loading predicate options:', error);
            }
        }

        function filterByPredicate(predicate) {
            if (!predicate) {
                renderGraph();
                return;
            }
            
            // Filter links by predicate
            const filteredLinks = graphData.links.filter(link => link.predicate === predicate);
            
            // Get nodes connected by filtered links
            const connectedNodeIds = new Set();
            filteredLinks.forEach(link => {
                connectedNodeIds.add(link.source);
                connectedNodeIds.add(link.target);
            });
            
            // Filter nodes
            const filteredNodes = graphData.nodes.filter(node => connectedNodeIds.has(node.id));
            
            // Create filtered graph data
            const filteredGraphData = {
                nodes: filteredNodes,
                links: filteredLinks,
            };
            
            // Render filtered graph
            renderGraphWithData(filteredGraphData);
        }

        async function loadCommunityGraph(dbName, communityId) {
            // Get community details
            const communityResponse = await fetch(`${API_BASE}/api/communities/${communityId}?db_name=${dbName}`);
            if (!communityResponse.ok) {
                throw new Error('Community not found');
            }

            const community = await communityResponse.json();
            
            // Build graph from community entities and relationships
            const nodes = new Map();
            const links = [];

            // Add all entities in community
            if (community.entities) {
                community.entities.forEach(entity => {
                    nodes.set(entity.entity_id, {
                        id: entity.entity_id,
                        name: entity.name || entity.canonical_name || entity.entity_id,
                        type: entity.type || 'OTHER',
                        isCenter: false,
                    });
                });
            }

            // Add relationships within community
            if (community.relationships) {
                community.relationships.forEach(rel => {
                    if (nodes.has(rel.subject_id) && nodes.has(rel.object_id)) {
                        links.push({
                            source: rel.subject_id,
                            target: rel.object_id,
                            predicate: rel.predicate,
                            confidence: rel.confidence,
                        });
                    }
                });
            }

            graphData = {
                nodes: Array.from(nodes.values()),
                links: links,
                community: {
                    id: community.community_id,
                    title: community.title,
                    summary: community.summary,
                    level: community.level,
                },
            };

            renderGraph();
            
            // Show community summary in detail panel
            if (community.summary) {
                const panel = document.getElementById('detailPanel');
                panel.innerHTML = `
                    <h3>${escapeHtml(community.title || 'Community')}</h3>
                    <p style="color: #aaa; font-size: 12px;">Level ${community.level} | ${community.entity_count} entities | ${community.relationship_count} relationships</p>
                    <p style="margin-top: 10px; color: #ccc;">${escapeHtml(community.summary)}</p>
                    <button class="close-btn" onclick="closeDetailPanel()">Close</button>
                `;
                panel.classList.add('active');
            }
        }

        async function loadEgoNetwork(dbName, entityId, maxNodes) {
            const maxHops = parseInt(document.getElementById('maxHops').value) || 2;
            
            // Use new ego network API
            const egoResponse = await fetch(
                `${API_BASE}/api/ego/network/${entityId}?db_name=${dbName}&max_hops=${maxHops}&max_nodes=${maxNodes}`
            );
            if (!egoResponse.ok) {
                throw new Error('Failed to load ego network');
            }

            const egoData = await egoResponse.json();
            
            if (egoData.error) {
                throw new Error(egoData.error);
            }
            
            // Build graph from ego network data
            const nodes = [];
            const links = [];

            // Add all nodes with hop level information
            egoData.nodes.forEach(node => {
                nodes.push({
                    id: node.entity_id,
                    name: node.name || node.canonical_name || node.entity_id,
                    type: node.type || 'OTHER',
                    isCenter: node.is_center || false,
                    hopLevel: node.hop_level || 0,
                });
            });

            // Add links
            egoData.links.forEach(link => {
                links.push({
                    source: link.source,
                    target: link.target,
                    predicate: link.predicate,
                    confidence: link.confidence,
                    hop: link.hop || 1,
                });
            });

            graphData = {
                nodes: nodes,
                links: links,
                centerEntity: egoData.center_entity,
            };

            renderGraph();
            
            // Show center entity info
            if (egoData.center_entity) {
                const panel = document.getElementById('detailPanel');
                panel.innerHTML = `
                    <h3>${escapeHtml(egoData.center_entity.name)}</h3>
                    <p style="color: #aaa; font-size: 12px;">Type: ${egoData.center_entity.type} | ${egoData.total_nodes} nodes | ${egoData.total_links} links</p>
                    <p style="margin-top: 10px; color: #ccc;">Ego network with ${maxHops}-hop neighborhood</p>
                    <button class="close-btn" onclick="closeDetailPanel()">Close</button>
                `;
                panel.classList.add('active');
            }
        }

        async function loadSampleGraph(dbName, maxNodes) {
            // Get top entities
            const entitiesResponse = await fetch(`${API_BASE}/api/entities/search?db_name=${dbName}&limit=${maxNodes}`);
            if (!entitiesResponse.ok) {
                throw new Error('Failed to load entities');
            }

            const entitiesData = await entitiesResponse.json();
            const entityIds = entitiesData.entities.map(e => e.entity_id).slice(0, maxNodes);

            // Get relationships between these entities
            const relationshipsResponse = await fetch(
                `${API_BASE}/api/relationships/search?db_name=${dbName}&limit=1000`
            );
            if (!relationshipsResponse.ok) {
                throw new Error('Failed to load relationships');
            }

            const relationshipsData = await relationshipsResponse.json();

            const nodes = new Map();
            const links = [];

            // Add nodes
            entitiesData.entities.forEach(entity => {
                nodes.set(entity.entity_id, {
                    id: entity.entity_id,
                    name: entity.name || entity.canonical_name || entity.entity_id,
                    type: entity.type || 'OTHER',
                    isCenter: false,
                });
            });

            // Add links (only between nodes in our set)
            relationshipsData.relationships.forEach(rel => {
                if (nodes.has(rel.subject_id) && nodes.has(rel.object_id)) {
                    links.push({
                        source: rel.subject_id,
                        target: rel.object_id,
                        predicate: rel.predicate,
                        confidence: rel.confidence,
                    });
                }
            });

            graphData = {
                nodes: Array.from(nodes.values()),
                links: links,
            };

            renderGraph();
        }

        function renderGraph() {
            renderGraphWithData(graphData);
        }

        function renderGraphWithData(data) {
            // Clear existing graph
            d3.select('#graph').selectAll('*').remove();

            const width = document.getElementById('graph').clientWidth;
            const height = document.getElementById('graph').clientHeight;

            svg = d3.select('#graph')
                .attr('width', width)
                .attr('height', height);

            // Create force simulation
            simulation = d3.forceSimulation(data.nodes)
                .force('link', d3.forceLink(data.links).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(30));

            // Create links
            const link = svg.append('g')
                .selectAll('line')
                .data(data.links)
                .enter()
                .append('line')
                .attr('class', 'link')
                .attr('stroke', '#666')
                .attr('stroke-width', d => Math.sqrt(d.confidence || 0.5) * 3);

            // Create nodes
            const node = svg.append('g')
                .selectAll('circle')
                .data(data.nodes)
                .enter()
                .append('circle')
                .attr('class', 'node')
                .attr('r', d => d.isCenter ? 12 : 8)
                .attr('fill', d => typeColors[d.type] || typeColors['OTHER'])
                .attr('stroke', '#fff')
                .attr('stroke-width', d => d.isCenter ? 3 : 2)
                .call(drag(simulation))
                .on('click', (event, d) => showNodeDetail(d));

            // Add labels
            const label = svg.append('g')
                .selectAll('text')
                .data(data.nodes)
                .enter()
                .append('text')
                .attr('class', 'node-label')
                .text(d => d.name.length > 15 ? d.name.substring(0, 15) + '...' : d.name)
                .attr('dx', 15)
                .attr('dy', 4);

            // Update positions on tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            // Zoom and pan
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    svg.selectAll('g').attr('transform', event.transform);
                });

            svg.call(zoom);
        }

        function drag(simulation) {
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            return d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended);
        }

        function showNodeDetail(node) {
            const panel = document.getElementById('detailPanel');
            panel.innerHTML = `
                <h3>${escapeHtml(node.name)}</h3>
                <p><strong>Type:</strong> ${escapeHtml(node.type)}</p>
                <p><strong>ID:</strong> ${escapeHtml(node.id)}</p>
                <button class="close-btn" onclick="closeDetailPanel()">Close</button>
            `;
            panel.classList.add('active');
        }

        function closeDetailPanel() {
            document.getElementById('detailPanel').classList.remove('active');
        }

        function resetView() {
            if (simulation) {
                simulation.alpha(1).restart();
            }
            if (svg) {
                svg.call(d3.zoom().transform, d3.zoomIdentity);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (svg && simulation) {
                const width = document.getElementById('graph').clientWidth;
                const height = document.getElementById('graph').clientHeight;
                svg.attr('width', width).attr('height', height);
                simulation.force('center', d3.forceCenter(width / 2, height / 2));
                simulation.alpha(1).restart();
            }
        });

        // Check for community_id in URL parameters
        window.addEventListener('load', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const communityId = urlParams.get('community_id');
            const dbName = urlParams.get('db_name');
            
            if (communityId && dbName) {
                document.getElementById('dbName').value = dbName;
                document.getElementById('communityId').value = communityId;
                loadGraph();
            }
        });

        function exportGraph() {
            if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
                showError('No graph data to export');
                return;
            }

            const format = prompt('Export format (json, csv, graphml, gexf):', 'json');
            if (!format) return;

            switch (format.toLowerCase()) {
                case 'json':
                    exportJSON();
                    break;
                case 'csv':
                    exportCSV();
                    break;
                case 'graphml':
                    exportGraphML();
                    break;
                case 'gexf':
                    exportGEXF();
                    break;
                default:
                    showError('Unsupported format. Use: json, csv, graphml, or gexf');
            }
        }

        function exportJSON() {
            const data = {
                nodes: graphData.nodes.map(n => ({
                    id: n.id,
                    name: n.name,
                    type: n.type,
                    isCenter: n.isCenter || false,
                })),
                links: graphData.links.map(l => ({
                    source: l.source,
                    target: l.target,
                    predicate: l.predicate,
                    confidence: l.confidence,
                })),
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `graph_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
        }

        function exportCSV() {
            const nodesCSV = [
                ['id', 'name', 'type', 'isCenter'].join(','),
                ...graphData.nodes.map(n => [
                    n.id,
                    `"${n.name.replace(/"/g, '""')}"`,
                    n.type,
                    n.isCenter || false,
                ].join(','))
            ].join('\n');

            const linksCSV = [
                ['source', 'target', 'predicate', 'confidence'].join(','),
                ...graphData.links.map(l => [
                    l.source,
                    l.target,
                    `"${(l.predicate || '').replace(/"/g, '""')}"`,
                    l.confidence || 0,
                ].join(','))
            ].join('\n');

            const csv = `Nodes:\n${nodesCSV}\n\nLinks:\n${linksCSV}`;
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `graph_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
        }

        function exportGraphML() {
            const xml = `<?xml version="1.0" encoding="UTF-8"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns
         http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  <key id="type" for="node" attr.name="type" attr.type="string"/>
  <key id="name" for="node" attr.name="name" attr.type="string"/>
  <key id="predicate" for="edge" attr.name="predicate" attr.type="string"/>
  <key id="confidence" for="edge" attr.name="confidence" attr.type="double"/>
  <graph id="G" edgedefault="directed">
${graphData.nodes.map(n => `    <node id="${n.id}">
      <data key="name">${escapeXml(n.name)}</data>
      <data key="type">${escapeXml(n.type)}</data>
    </node>`).join('\n')}
${graphData.links.map(l => `    <edge source="${l.source}" target="${l.target}">
      <data key="predicate">${escapeXml(l.predicate || '')}</data>
      <data key="confidence">${l.confidence || 0}</data>
    </edge>`).join('\n')}
  </graph>
</graphml>`;

            const blob = new Blob([xml], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `graph_${new Date().toISOString().split('T')[0]}.graphml`;
            a.click();
        }

        function exportGEXF() {
            const xml = `<?xml version="1.0" encoding="UTF-8"?>
<gexf xmlns="http://www.gexf.net/1.2draft" version="1.2">
  <meta>
    <creator>GraphRAG Pipeline Visualization</creator>
    <description>Exported graph</description>
  </meta>
  <graph mode="static" defaultedgetype="directed">
    <attributes class="node">
      <attribute id="type" title="Type" type="string"/>
      <attribute id="name" title="Name" type="string"/>
    </attributes>
    <attributes class="edge">
      <attribute id="predicate" title="Predicate" type="string"/>
      <attribute id="confidence" title="Confidence" type="double"/>
    </attributes>
    <nodes>
${graphData.nodes.map(n => `      <node id="${n.id}" label="${escapeXml(n.name)}">
        <attvalues>
          <attvalue for="type" value="${escapeXml(n.type)}"/>
          <attvalue for="name" value="${escapeXml(n.name)}"/>
        </attvalues>
      </node>`).join('\n')}
    </nodes>
    <edges>
${graphData.links.map((l, i) => `      <edge id="e${i}" source="${l.source}" target="${l.target}">
        <attvalues>
          <attvalue for="predicate" value="${escapeXml(l.predicate || '')}"/>
          <attvalue for="confidence" value="${l.confidence || 0}"/>
        </attvalues>
      </edge>`).join('\n')}
    </edges>
  </graph>
</gexf>`;

            const blob = new Blob([xml], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `graph_${new Date().toISOString().split('T')[0]}.gexf`;
            a.click();
        }

        function escapeXml(text) {
            if (!text) return '';
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }
    </script>
</body>
</html>

